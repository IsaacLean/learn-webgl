<!DOCTYPE html>
<html>
<head>
	<title>WebGL Tutorial</title>
	<script src="lib/glMatrix-0.9.5.min.js"></script>
	<script id="shader-fs" type="x-shader/x-fragment">
	    precision mediump float;

	    void main(void) {
	        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
	    }
	</script>
	<script id="shader-vs" type="x-shader/x-vertex">
	    attribute vec3 aVertexPosition;

	    uniform mat4 uMVMatrix;
	    uniform mat4 uPMatrix;

	    void main(void) {
	        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	    }
	</script>
	<script>
		var gl;
	    function initGL(canvas) {
	        try {
	            gl = canvas.getContext("experimental-webgl");
	            gl.viewportWidth = canvas.width;
	            gl.viewportHeight = canvas.height;
	        } catch (e) {
	        }
	        if (!gl) {
	            alert("Could not initialise WebGL, sorry :-(");
	        }
	    }

	    function getShader(gl, id) {
	        var shaderScript = document.getElementById(id);
	        if (!shaderScript) {
	            return null;
	        }

	        var str = "";
	        var k = shaderScript.firstChild;
	        while (k) {
	            if (k.nodeType == 3) {
	                str += k.textContent;
	            }
	            k = k.nextSibling;
	        }

	        var shader;
	        if (shaderScript.type == "x-shader/x-fragment") {
	            shader = gl.createShader(gl.FRAGMENT_SHADER);
	        } else if (shaderScript.type == "x-shader/x-vertex") {
	            shader = gl.createShader(gl.VERTEX_SHADER);
	        } else {
	            return null;
	        }

	        gl.shaderSource(shader, str);
	        gl.compileShader(shader);

	        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	            alert(gl.getShaderInfoLog(shader));
	            return null;
	        }

	        return shader;
	    }

	    var shaderProgram;
	    function initShaders() {
	        var fragmentShader = getShader(gl, "shader-fs");
	        var vertexShader = getShader(gl, "shader-vs");

	        shaderProgram = gl.createProgram();
	        gl.attachShader(shaderProgram, vertexShader);
	        gl.attachShader(shaderProgram, fragmentShader);
	        gl.linkProgram(shaderProgram);

	        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	            alert("Could not initialise shaders");
	        }

	        gl.useProgram(shaderProgram);

	        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

	        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	    }

	    var mvMatrix = mat4.create();
	    var pMatrix = mat4.create();
	    function setMatrixUniforms() {
	        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	    }

	    var triangleVertexPositionBuffer; //create global variable to hold buffer
		function initBuffers() {
			triangleVertexPositionBuffer = gl.createBuffer(); //create a buffer for vertex positions
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer); //any following operations that act on buffers should use the one we specify
			var vertices = [
				0, 1, 0,
				-1, -1, 0,
				1, -1, 0
			]; //define the vertex positions as a list, this is an isosceles triangle with its center at (0, 0, 0)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //create a Float32Array object based on list and tell WebGL to use it to fill the current buffer
			triangleVertexPositionBuffer.itemSize = 3; //each item is made up of 3 numbers
			triangleVertexPositionBuffer.numItems = 3; ///9-element buffer represents 3 separate vertex positions
		}

		function drawScene() {
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); //tell WebGL size of canvas
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //clear the canvas in preparation for drawing on it
			mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100, pMatrix); //makes things further away look smaller by telling WebGL the perspective we're using: vertical FOV 45 degrees, width-to-height ratio of our canvas, we don't want to see things closer than 0.1 units to our viewpoint, we don't want to see things that are away than 100 units
			mat4.identity(mvMatrix); //sets "identity matrix" which represents a transformation that does nothing at all, the combined matrix of all transformations on top of identity matrix is the "model-view matrix", basically we moved to an origin point from which we can move to start drawing the world

			mat4.translate(mvMatrix, [-1.5, 0, -7]); //start triangle by moving 1.5 units to left and 7 units into scene
			//gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer); //redundant because we are drawing one item?
			gl.vertexAttribPointer(shaderProgram.triangleVertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0); //values in buffer should be used for vertex positions
			setMatrixUniforms(); //tells WebGL to take account for current model-view matrix. you can edit mvMatrix all you want, but this happens in JS's private space. this function moves it over to the GPU.
			gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems); //draw array of vertices starting with 0 in array to the "numItems"th element, WebGL will now draw triangle
		}

		function webGLStart() {
			var canvas = document.getElementById('canvas');
			initGL(canvas);
			initShaders();
			initBuffers();

			gl.clearColor(0, 0, 0, 1); //make canvas black
			gl.enable(gl.DEPTH_TEST); //do depth testing so things drawn behind other things should be hidden by things in front of them

			drawScene(); //draws triangle using the buffers
		}
	</script>
	<style>
		body {
			background-color: #ccc;
		}
	</style>
</head>
<body onload="webGLStart();">
	<canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>