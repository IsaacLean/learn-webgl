<!DOCTYPE html>
<html>
<head>
	<title>WebGL Tutorial</title>
	<script src="lib/glMatrix-0.9.5.min.js"></script>
	<!--these shaders are technically written in GLSL not JS-->
	<script id="shader-fs" type="x-shader/x-fragment">
	    precision mediump float; //obligatory boilerplate code that tells GPU how precise we want to be with floats. medium precision (mediump) is good because it's required to be supported by all WebGL devices, high precision (highp) doesn't work on all mobile devices

	    varying vec4 vColor;

	    void main(void) {
	        gl_FragColor = vColor;
	    }
	</script>
	<script id="shader-vs" type="x-shader/x-vertex">
		//these two attributes are inputs that vary from vertex to vertex
	    attribute vec3 aVertexPosition; //shader is called for every vertex and the vertex is passed in to the shader as this variable thanks to the use of vertexPositionAttribute in the drawScene
	    attribute vec4 aVertexColor;

	    //uniform variables can be accessed from outside the shader, they are non-varying
	    uniform mat4 uMVMatrix;
	    uniform mat4 uPMatrix;

	    varying vec4 vColor; //output in the form of varying variable

	    void main(void) {
	        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); //multiplies vertex position with model-view and projection matrices and pushes out the result as the final position of the vertex
	        vColor = aVertexColor; //pass color straight through from the input attribute to the output varying variable
	    }
	</script>
	<script>
		var gl;
	    function initGL(canvas) {
	        try {
	            gl = canvas.getContext('experimental-webgl'); //gets WebGL context
	            //JS allows us to set any property we like on any object, so we will store canvas width and height for viewport/perspective later
	            gl.viewportWidth = canvas.width;
	            gl.viewportHeight = canvas.height;
	        } catch (e) {
	        }
	        if (!gl) {
	            alert('Could not initialise WebGL, sorry :(');
	        }
	    }

	    //create fragment or vertex shader based on type and pass off to WebGL to be compiled into a form that runs on GPU
	    function getShader(gl, id) {
	        var shaderScript = document.getElementById(id);
	        if (!shaderScript) {
	            return null;
	        }

	        var str = '';
	        var k = shaderScript.firstChild;
	        while (k) {
	            if (k.nodeType == 3) {
	                str += k.textContent;
	            }
	            k = k.nextSibling;
	        }

	        var shader;
	        if (shaderScript.type == 'x-shader/x-fragment') {
	            shader = gl.createShader(gl.FRAGMENT_SHADER);
	        } else if (shaderScript.type == 'x-shader/x-vertex') {
	            shader = gl.createShader(gl.VERTEX_SHADER);
	        } else {
	            return null;
	        }

	        gl.shaderSource(shader, str);
	        gl.compileShader(shader);

	        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	            alert(gl.getShaderInfoLog(shader));
	            return null;
	        }

	        return shader;
	    }

	    var shaderProgram;
	    function initShaders() {
	        var fragmentShader = getShader(gl, 'shader-fs'); //get fragment shader
	        var vertexShader = getShader(gl, 'shader-vs'); //get vertex shader

	        shaderProgram = gl.createProgram(); //program is code that lives on the WebGL side of system which runs on the GPU
	        gl.attachShader(shaderProgram, vertexShader);
	        gl.attachShader(shaderProgram, fragmentShader);
	        gl.linkProgram(shaderProgram);

	        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	            alert('Could not initialise shaders');
	        }

	        gl.useProgram(shaderProgram);

	        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
	        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute); //tells WebGL we will want to provide values for the attribute using an array

	        //get attribute locations which is how we get a reference to the attributes that we want to pass to the vertex shader for each vertex
	        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, 'aVertexColor');
	        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

	        //store locations of uniform variables on program object for convenience
	        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
	        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
	    }

	    //moves model-view and projection matrices up from JS to WebGL by using references to the uniforms
	    var mvMatrix = mat4.create(); //set model-view matrix to all-zero matrices
	    var pMatrix = mat4.create(); //set projection matrix to all-zero matrices. project matrix stores how the program makes things proportionally smaller when they are farther away. populated by mat4.perspective().
	    function setMatrixUniforms() {
	        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	    }

	    //create global variable to hold buffers
	    var triangleVertexPositionBuffer;
	    var triangleVertexColorBuffer;
	    var squareVertexPositionBuffer;
	    var squareVertexColorBuffer;
		function initBuffers() {
			triangleVertexPositionBuffer = gl.createBuffer(); //create a buffer for vertex positions
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer); //any following operations that act on buffers should use the one we specify
			var vertices = [
				0, 1, 0,
				-1, -1, 0,
				1, -1, 0
			]; //define the vertex positions as a list, this is an isosceles triangle with its center at (0, 0, 0)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //create a Float32Array object based on list and tell WebGL to use it to fill the current buffer
			triangleVertexPositionBuffer.itemSize = 3; //each item is made up of 3 numbers
			triangleVertexPositionBuffer.numItems = 3; //9-element buffer represents 3 separate vertex positions
			triangleVertexColorBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
			var colors = [
				1, 0, 0, 1,
				0, 1, 0, 1,
				0, 0, 1, 1
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
			triangleVertexColorBuffer.itemSize = 4;
			triangleVertexColorBuffer.numItems = 3;

			//setup buffer for square
			squareVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			vertices = [
				1, 1, 0,
				-1, 1, 0,
				1, -1, 0,
				-1, -1, 0
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			squareVertexPositionBuffer.itemSize = 3;
			squareVertexPositionBuffer.numItems = 4;
			squareVertexColorBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
			colors = [];
			for(var i = 0; i < 4; ++i) {
				colors = colors.concat([0.5, 0.5, 1, 1]);
			}
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
			squareVertexColorBuffer.itemSize = 4;
			squareVertexColorBuffer.numItems = 4;
		}

		function drawScene() {
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); //tell WebGL size of canvas
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //clear the canvas in preparation for drawing on it
			mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100, pMatrix); //makes things further away look smaller by telling WebGL the perspective we're using: vertical FOV 45 degrees, width-to-height ratio of our canvas, we don't want to see things closer than 0.1 units to our viewpoint, we don't want to see things that are away than 100 units. populate pMatrix with this data.
			mat4.identity(mvMatrix); //sets "identity matrix" which represents a transformation that does nothing at all, the combined matrix of all transformations on top of identity matrix is the "model-view matrix", basically we moved to an origin point from which we can move to start drawing the world

			//start drawing the triangle
			mat4.translate(mvMatrix, [-1.5, 0, -7]); //start triangle by moving 1.5 units to left and 7 units into scene
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.triangleVertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0); //values in buffer should be used for vertex positions
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, triangleVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			setMatrixUniforms(); //tells WebGL to take account for current model-view matrix. you can edit mvMatrix all you want, but this happens in JS's private space. this function moves it over to the GPU.
			gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems); //draw array of vertices starting with 0 in array to the "numItems"th element, WebGL will now draw triangle

			//next draw the square
			mat4.translate(mvMatrix, [3, 0, 0]);
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, squareVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			setMatrixUniforms();
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems); //gl.TRIANGLE_STRIP: first triangle uses three vertices, next triangle uses last two vertices from previous triangle and next unused vertex, next triangle etc...
		}

		function webGLStart() {
			var canvas = document.getElementById('canvas');
			initGL(canvas);
			initShaders();
			initBuffers();

			gl.clearColor(0, 0, 0, 1); //make canvas black
			gl.enable(gl.DEPTH_TEST); //do depth testing so things drawn behind other things should be hidden by things in front of them

			drawScene(); //draws triangle using the buffers
		}
	</script>
	<style>
		body {
			background-color: #ccc;
		}
	</style>
</head>
<body onload="webGLStart();">
	<canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>